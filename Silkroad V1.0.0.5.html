
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Grand Silk Road ‚Äî by mO</title>
<link rel="stylesheet" href="silkroad-style.css?v=1.0.0.6">
</head>

<body>

<div class="container">
<div class="map" id="map">
  <!-- üé≤ Floating 3D Dice -->
  <div class="floating-dice">
    <div class="dice green" id="greenDie">-</div>
    <div class="dice red" id="redDie">-</div>
  </div>
</div>

  <div class="sidebar"> 
 </div>
    <div class="panel">

<!-- ‚ú® Floating Sign-In Panel -->
<div class="login-floating" id="loginPanel">
  <h2>üèïÔ∏è Caravan Entry</h2>
  <input id="newPlayerName" type="text" placeholder="Player name..." />
  <div class="btns">
    <button id="addPlayerBtn">Add a player</button>
    <button id="addAIPlayerBtn" class="ai">Robot ü§ñ</button>
    <button id="startBtn" class="primary"> Start </button>
  </div>
  <button id="resetBtn" class="reset">‚ü≥</button>
</div>

<!-- ü™Ñ After Start (Mini Floating Glass Panel) -->
<div class="after-start-floating hidden-panel" id="afterStartPanel">
  <button id="resetBtn2" class="primary">üåü Start a new game</button>
</div>


<script>
/* üîÅ Hide floating sign-in after Start */
document.getElementById("startBtn").addEventListener("click", () => {
  const loginPanel = document.getElementById("loginPanel");
  const afterStartPanel = document.getElementById("afterStartPanel");
  setTimeout(() => {
    loginPanel.classList.add("hidden-panel");
    afterStartPanel.classList.remove("hidden-panel");
  }, 600);
});
document.getElementById("resetBtn2").onclick = () => location.reload();
</script>

    <div class="panel">

<br/> <br/> <br/>

      <strong></strong>
<br/> <br/>

      <strong></strong>

      <div id="currentTownText"> üèôÔ∏è price: </div><br/>

      <div id="turnBanner">Waiting for players...</div><br/>

    <div class="panel">


      <strong>Players <br/> <br/> </strong>

<div id="playersTableContainer" class="players-container"></div>

    </div>
	
    <div class="panel">
      <strong>Log</strong>

<div id="log"></div>

<div id="ytWrapper" style="display:none; text-align:center; margin-top:10px;">
  <iframe id="ytFrame" width="360" height="215"
    src=""
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowfullscreen>
  </iframe>
</div>

    </div>
  </div>
</div>

<script>


/* üîÅ Hide login panel after start */
document.getElementById("startBtn").addEventListener("click", () => {
  const loginPanel = document.getElementById("loginPanel");
  const afterStartPanel = document.getElementById("afterStartPanel");
  setTimeout(() => {
    loginPanel.classList.add("hidden-panel");
    afterStartPanel.classList.remove("hidden-panel");
  }, 600);
});
document.getElementById("resetBtn2").onclick = () => location.reload();

/* =========================================
   MODULE 1: Game State
   ========================================= */
const GameState = {
  towns: ["Tianlu","Ozon","Daruk","Samurai","Turkhan","Marzban","Seraphis","Tsafir","Nimar","Valon","Zemara","Artava","Azharan","Qashim","Liavera","Oravan","Novar","Shariza","Gate of Dusk"],
  prices: [1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100],
  players: [],
  activeIndex: 0,
  currentTown: 9,
  started: false,
  palette: ["#ff4d4d","#34c759","#007aff","#ff9500","#af52de","#5ac8fa"]
};

/* =========================================
   MODULE 2: UI
   ========================================= */
const UI = {
  map: document.getElementById("map"),
  logBox: document.getElementById("log"),
  townText: document.getElementById("currentTownText"),
  greenDie: document.getElementById("greenDie"),
  redDie: document.getElementById("redDie"),
  turnBanner: document.getElementById("turnBanner"),

  log(msg) {
    const div = document.createElement("div");
    div.textContent = msg;
    this.logBox.prepend(div);

    // üîî Floating notification
    if (typeof Notifications !== "undefined") {
      Notifications.show(msg);
    }
  },

  updateTown() {
    const i = GameState.currentTown;
    const townName = GameState.towns[i];
    const price = GameState.prices[i];

    this.townText.innerHTML = `
      üèôÔ∏è You are in 
      <span class="town-name">${townName}</span> City &nbsp;&nbsp;
      <br>üê™ Camel price 
      <span class="price-flash">$${price}</span>
    `;

    document.querySelectorAll(".node").forEach(n => n.classList.remove("town-current"));
    const node = document.querySelector(`.node[data-index="${i}"]`);
    if (node) node.classList.add("town-current");
  },

townCoords: [
  [60, 82],  // Tianlu ($1) ‚Äî Bottom
  [55, 78],  // Ozon ($2)
  [50, 74],  // Daruk ($3)
  [45, 70],  // Samurai ($4)
  [40, 66],  // Turkhan ($5)
  [35, 62],  // Marzban ($6)
  [32, 58],  // Seraphis ($7)
  [38, 54],  // Tsafir ($8)
  [44, 50],  // Nimar ($9)
  [50, 46],  // Valon ($10)
  [45, 42],  // Zemara ($20)
  [40, 38],  // Artava ($30)
  [35, 34],  // Azharan ($40)
  [30, 30],  // Qashim ($50)
  [34, 26],  // Liavera ($60)
  [38, 22],  // Oravan ($70)
  [44, 18],  // Novar ($80)
  [50, 14],  // Shariza ($90)
  [56, 10],  // Gate of Dusk ($100) ‚Äî Top
],

  createNode(index, name, price) {
    const div = document.createElement("div");
    div.className = "node";
    div.dataset.index = index;
    div.innerHTML = `
      <div class="price-main">$${price}</div>
      <div class="town-small">${name}</div>
    `;

    // ÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™
    if (this.townCoords && this.townCoords[index]) {
      let [x, y] = this.townCoords[index];
      x = Math.max(0, Math.min(100, x));
      y = Math.max(0, Math.min(100, y));
      div.style.left = x + "%";
      div.style.top = y + "%";
    }

    div.style.position = "absolute";
    div.style.zIndex = 10;
    this.map.appendChild(div);
  },

refreshTable() {
  const container = document.querySelector("#playersTableContainer");
  if (!container) return;
  container.innerHTML = "";

  GameState.players.forEach((p, i) => {
    const avg = p.camels ? (p.totalSpent / p.camels).toFixed(1) : "-";
    const wealth = (p.gold + p.camels * GameState.prices[GameState.currentTown]).toFixed(1);

    const card = document.createElement("div");
    card.className = "player-card";
    if (i === GameState.activeIndex) card.classList.add("active");

    card.style.borderColor = p.color;
    card.style.background = `${p.color}15`;
    card.style.color = p.color;

card.innerHTML = `
  <div class="player-header">
    <div>
      <span class="player-dot-inline" style="background:${p.color}"></span>
      ${p.name} ${p.isAI ? "ü§ñ" : "üßç"}
    </div>
    <div class="turn-status">${i === GameState.activeIndex ? "üéØ Your Turn" : ""}</div>
  </div>

  <hr class="player-divider" />

  <div class="player-info-grid">
    <div><span class="icon">üê™</span> <strong>${p.camels}</strong> Camels</div>
    <div><span class="icon">üí≤</span> <strong>${p.gold}</strong> Gold</div>
  </div>
`;

    // ‚úÖ If it's this player's turn and not AI, show trade buttons
    if (i === GameState.activeIndex && !p.isAI && GameState.started) {
      const btnArea = document.createElement("div");
      btnArea.className = "inline-buttons";

btnArea.innerHTML = `
  <div class="number-input">
    <button class="num-btn minus">‚Äì</button>
    <input type="number" id="inlineCamelCount" value="1" min="1" />
    <button class="num-btn plus">+</button>
  </div>
  <button class="inline-buy">Buy</button>
  <button class="inline-sell">Sell</button>
  <button class="inline-wait">Wait</button>
`;

const input = btnArea.querySelector("#inlineCamelCount");
btnArea.querySelector(".plus").onclick = () => input.stepUp();
btnArea.querySelector(".minus").onclick = () => input.stepDown();

      card.appendChild(btnArea);

      // connect functionality
      const buy = btnArea.querySelector(".inline-buy");
      const sell = btnArea.querySelector(".inline-sell");
      const wait = btnArea.querySelector(".inline-wait");
      const countInput = btnArea.querySelector("#inlineCamelCount");

      const price = GameState.prices[GameState.currentTown];
      buy.disabled = (p.gold < price);
      sell.disabled = (p.camels <= 0);

      buy.onclick = () => {
        const n = +countInput.value;
        PlayerActions.buy(p, n);
        UI.refreshTable();
        GameFlow.playerActed();
      };
      sell.onclick = () => {
        const n = +countInput.value;
        PlayerActions.sell(p, n);
        UI.refreshTable();
        GameFlow.playerActed();
      };
      wait.onclick = () => {
        UI.log(`${p.name} waits.`);
        GameFlow.playerActed();
      };
    }

    container.appendChild(card);
  });
},

  highlightActivePlayer() {
    const active = GameState.players[GameState.activeIndex];
    this.turnBanner.textContent = `üéØ ${active.name}'s Turn ${active.isAI ? "(AI)" : ""}`;

    GameState.players.forEach((p, i) =>
      p.dotEl.classList.toggle("active", i === GameState.activeIndex)
    );

    const cards = document.querySelectorAll(".player-card");
    cards.forEach((card, i) => {
      card.classList.toggle("active", i === GameState.activeIndex);
    });

  }   // ‚úÖ close the function properly
};     // ‚úÖ close the whole UI object properly

/* =========================================
   MODULE 3: Player Actions
   ========================================= */
const PlayerActions={
  buy(p,n){
    const price=GameState.prices[GameState.currentTown];
    if(p.gold<price*n) return UI.log(`${p.name} can't afford that.`);
    p.gold-=price*n;
    p.camels+=n;
    p.totalSpent+=price*n;
    UI.log(`${p.name} bought ${n} camels at $${price}`);
  },
  sell(p,n){
    const price=GameState.prices[GameState.currentTown];
    if(p.camels<n) return UI.log(`${p.name} has not enough camels.`);
    const avg=p.camels?(p.totalSpent/p.camels):0;
    p.camels-=n;
    p.gold+=price*n;
    p.totalSpent-=avg*n;
    UI.log(`${p.name} sold ${n} camels at $${price}`);
  }
};

/* =========================================
   MODULE 4: Game Flow ‚Äî Round-based & synchronized dice
   - ŸÉŸÑ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ŸäÿÆÿ™ÿßÿ±Ÿàÿß ÿ£ŸàŸÑÿßŸãÿå ÿ´ŸÖ ŸÜÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ± ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ© ŸÑŸÑÿ¨ŸÖŸäÿπ
   - ŸäÿØŸäÿ± ÿßŸÑŸÄ turn progression ŸàÿßŸÑŸÄ caravan movement
   ========================================= */
const GameFlow = (function () {
  // private state
  let actionsTaken = 0;         // ŸÉŸÖ ŸÑÿßÿπÿ® ÿ£ŸÜŸáŸâ ÿßÿÆÿ™Ÿäÿßÿ±Ÿá ŸÅŸä ÿßŸÑŸÄ round ÿßŸÑÿ≠ÿßŸÑŸä
  let roundNumber = 1;

  return {
    // ŸÖÿπÿßŸÑÿ¨ Ÿäÿ≥ÿ™ÿÆÿØŸÖŸá ŸÉŸÑ ÿ≤ÿ±/AI ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑŸÑÿßÿπÿ® ŸÖŸÜ ÿπŸÖŸÑŸá
    // Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿØÿπÿßÿ§Ÿá ÿ®ÿπÿØ ÿ™ŸÜŸÅŸäÿ∞ ÿπŸÖŸÑŸäÿ© (buy/sell/wait) ŸÑŸÑŸÑÿßÿπÿ® ÿßŸÑÿ≠ÿßŸÑŸä
    playerActed() {
      actionsTaken++;
      UI.log(`‚úÖ Action registered (${actionsTaken}/${GameState.players.length})`);
      // ŸÑŸà ŸÉŸÑ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿ£ŸÜŸáŸàÿß ‚Äî ŸÜŸÖÿ∂Ÿä ÿ•ŸÑŸâ ÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ± Ÿàÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÇÿßŸÅŸÑÿ©
      if (actionsTaken >= GameState.players.length) {
        actionsTaken = 0; // reset for next round
        roundNumber++;
        UI.log(`üîî All players acted ‚Äî rolling dice for round ${roundNumber}`);
        this.executeRoundMovement();
      }
      // ÿ®ÿπÿØ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÅÿπŸÑÿå ŸÜŸÜÿ™ŸÇŸÑ ŸÑŸÑŸëÿßÿπÿ® ÿßŸÑÿ™ÿßŸÑŸä (Ÿáÿ∞Ÿá ÿßŸÑŸàÿ∏ŸäŸÅÿ© ŸÑÿß ÿ™ÿ™ÿ≠ŸÉŸÖ ÿ®ÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ±)
      this.advanceActivePlayer();
    },

    // ÿßŸÑÿ™ŸÇÿØŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ™ÿßŸÑŸä (ŸÑÿß Ÿäÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ±)
    advanceActivePlayer() {
      GameState.activeIndex = (GameState.activeIndex + 1) % GameState.players.length;
      UI.refreshTable();
      UI.highlightActivePlayer();

      // ÿ•ÿ∞ÿß ÿßŸÑÿ™ÿßŸÑŸä AIÿå ÿßÿ∑ŸÑÿ® ŸÖŸÜŸá ÿßŸÑÿ™ŸÅŸÉŸäÿ±/ÿßŸÑÿ™ÿµÿ±ŸÅ ŸÉŸÖÿß ŸÇÿ®ŸÑÿßŸã
      const current = GameState.players[GameState.activeIndex];
      if (current && current.isAI) {
        // ŸÜÿ™ÿ±ŸÉ aiTakeTurn ŸÉŸÖÿß ŸáŸà ‚Äî ÿπŸÑŸäŸá ÿ£ŸÜ ŸäŸÜÿßÿØŸä playerActed() ÿ®ÿπÿØ ŸÇÿ±ÿßÿ±Ÿá
        aiTakeTurn(current);
      }
    },

    // ÿ∑ÿ±ŸäŸÇÿ© ŸÑÿ±ŸÖŸä ŸÜÿ±ÿØ (1..6)
    rollDie() {
      return Math.floor(Math.random() * 6) + 1;
    },

    // ÿ™ŸÜŸÅŸäÿ∞ ÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ± Ÿàÿßÿ∏Ÿáÿßÿ± ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿ´ŸÖ ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÇÿßŸÅŸÑÿ© ÿ®ÿπÿØ ŸÖŸáŸÑÿ© ŸÇÿµŸäÿ±ÿ©
    executeRoundMovement() {
      // üé≤ Roll
      const g = this.rollDie();
      const r = this.rollDie();

      // ÿπÿ±ÿ∂ ÿßŸÑÿ£ÿ±ŸÇÿßŸÖ ŸÅŸàÿ±Ÿãÿß (animation)
      UI.greenDie.textContent = g;
      UI.redDie.textContent = r;
      UI.greenDie.classList.add("roll");
      UI.redDie.classList.add("roll");
      setTimeout(() => {
        UI.greenDie.classList.remove("roll");
        UI.redDie.classList.remove("roll");
      }, 500);

      // ÿ™ÿ∑ÿ®ŸäŸÇ ŸÇŸàÿßÿπÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿÆÿßÿµ: ÿ™ÿ¨ÿßŸáŸÑ ÿ£ÿ≠ÿØ ÿßŸÑÿ£ŸÜŸàÿßÿπ ÿ≠ÿ≥ÿ® ÿßŸÑŸÖÿØŸäŸÜÿ©
      const currentPrice = GameState.prices[GameState.currentTown];
      let usedGreen = true, usedRed = true;

      if (currentPrice === 1) {
        usedRed = false; // ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿØŸÜ ÿ™ÿ≠ÿ™ -> ŸÑÿß ŸÜÿ£ÿÆÿ∞ ÿßŸÑÿ£ÿ≠ŸÖÿ±
        UI.log("‚ÑπÔ∏è At bottom city (price 1): Ignoring RED die.");
      } else if (currentPrice === 100) {
        usedGreen = false; // ŸÅŸä ÿßŸÑŸÇŸÖÿ© -> ŸÑÿß ŸÜÿ£ÿÆÿ∞ ÿßŸÑÿ£ÿÆÿ∂ÿ±
        UI.log("‚ÑπÔ∏è At top city (price 100): Ignoring GREEN die.");
      }

      // ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÅÿßÿ±ŸÇ ÿ£Ÿà ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÅÿπŸÑŸäÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿØÿØ ÿßŸÑÿ™ÿ≠ÿ±ŸÉ
      // ŸÖŸÜÿ∑ŸÇ: ÿ•ÿ∞ÿß ÿ£ÿ≠ÿØ ÿßŸÑŸÜÿ±ÿØŸäŸÜ ŸÖŸèŸáŸÖŸÑ ŸÜÿ≥ÿ™ÿÆÿØŸÖ ŸÇŸäŸÖÿ© ÿßŸÑÿ¢ÿÆÿ± (ŸÖŸÇÿØÿßÿ± ÿßŸÑÿ™ÿ≠ÿ±ŸÉ) Ÿàÿ®ÿßÿ™ÿ¨ÿßŸáŸá.
      // ÿ•ÿ∞ÿß ŸÉŸÑÿßŸáŸÖÿß ŸÖÿ≥ÿ™ÿÆÿØŸÖÿßŸÜÿå ŸÜÿ≠ÿ≥ÿ® ÿßŸÑŸÅÿ±ŸÇ (abs) ŸàŸÜÿ£ÿÆÿ∞ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿ≠ÿ≥ÿ® ÿßŸÑÿ£ŸÉÿ®ÿ±.
      let diff = 0;
      let direction = "none";
      if (usedGreen && !usedRed) {
        diff = g;
        direction = "green-only";
      } else if (!usedGreen && usedRed) {
        diff = r;
        direction = "red-only";
      } else if (usedGreen && usedRed) {
        if (g > r) { diff = g - r; direction = "up"; }
        else if (r > g) { diff = r - g; direction = "down"; }
        else { diff = 0; direction = "equal"; }
      }

      // üëÄ ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ŸÇÿ®ŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸÑŸÖÿØÿ© ŸÇÿµŸäÿ±ÿ© ŸÉŸä Ÿäÿ≥ÿ™Ÿàÿπÿ® ÿßŸÑŸÑÿßÿπÿ®ŸàŸÜ
      let directionText = "";
      if (direction === "green-only") directionText = `‚¨ÜÔ∏è Move UP ${diff} step${diff>1?"s":""} (GREEN only)`;
      else if (direction === "red-only") directionText = `‚¨áÔ∏è Move DOWN ${diff} step${diff>1?"s":""} (RED only)`;
      else if (direction === "up") directionText = `‚¨ÜÔ∏è Move UP ${diff} step${diff>1?"s":""}`;
      else if (direction === "down") directionText = `‚¨áÔ∏è Move DOWN ${diff} step${diff>1?"s":""}`;
      else directionText = `‚öñÔ∏è No movement (equal dice).`;

      const resultMsg = `üé≤ Dice: Green ${g} | Red ${r} ‚Üí ${directionText}`;
      UI.log(resultMsg);
      if (typeof Notifications !== "undefined") Notifications.show(resultMsg, { level: "important", duration: 2000 });

      // ÿ®ÿπÿØ 2000ms ŸÜŸÜŸÅÿ∞ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÅÿπŸÑŸäÿ©
      setTimeout(() => {
        // ÿ•ÿ∞ÿß diff === 0 => ŸÑÿß ÿ≠ÿ±ŸÉÿ©
        if (diff <= 0) {
          UI.log("üê™ Caravan stays in place this round.");
          if (typeof Notifications !== "undefined") Notifications.show("üê™ Caravan stays in place.", { duration: 1800 });
          UI.updateTown();
          UI.refreshTable();
          positionPlayers();
          UI.highlightActivePlayer();
          return;
        }

        const prevIndex = GameState.currentTown;
        let newIndex = prevIndex;

        if (direction === "green-only" || direction === "up") {
          newIndex = Math.min(GameState.towns.length - 1, prevIndex + diff);
        } else if (direction === "red-only" || direction === "down") {
          newIndex = Math.max(0, prevIndex - diff);
        }

        // ÿ≥ÿ¨ŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿ© Ÿàÿ≠ÿØÿ´ ÿßŸÑŸàÿßÿ¨Ÿáÿ©
        if (newIndex !== prevIndex) {
          GameState.currentTown = newIndex;
          const newTown = GameState.towns[newIndex];
          UI.log(`üê™ Caravan moved ${diff} ‚Üí ${newTown}`);
          if (typeof Notifications !== "undefined") Notifications.show(`üê™ Caravan reached ${newTown}`, { level: "good", duration: 2400 });
        } else {
          UI.log("üê™ Caravan tried to move but reached boundary (stays).");
          if (typeof Notifications !== "undefined") Notifications.show("üê™ Caravan at map boundary ‚Äî stays.", { duration: 1800 });
        }

        UI.updateTown();
        UI.refreshTable();
        positionPlayers();
        UI.highlightActivePlayer();
      }, 2000); // 2s delay for player awareness
    },

    // expose for external calls if ever needed (read-only)
    getRoundNumber() { return roundNumber; },

    // helper: reset round counters (rarely needed externally)
    resetRound() {
      actionsTaken = 0;
      UI.log("üîÅ Round counters reset.");
    }
  };
})(); 

/* =========================================
   MODULE 5: Setup and Event Handlers
   ========================================= */
function init(){
  GameState.towns.forEach((t,i)=>UI.createNode(i,t,GameState.prices[i]));
  UI.updateTown();
  UI.log("‚úÖ Ready");
}

function addPlayer(name, isAI = false) {
  if (!name) return;
  const color = GameState.palette[GameState.players.length % GameState.palette.length];
  const p = {
    name,
    gold: 10,
    camels: 0,
    totalSpent: 0,
    isAI,
    color, // ‚úÖ store color for table use
    dotEl: document.createElement("div")
  };

  p.dotEl.className = "player-dot";
  p.dotEl.style.background = color;
  p.dotEl.style.color = color; // üÜï added line for glowing in player color

  GameState.players.push(p);
  UI.map.appendChild(p.dotEl);

  positionPlayers();
  UI.refreshTable();
  UI.log(`${name} joined ${isAI ? "(AI)" : ""}`);
}

function positionPlayers() {
  const node = document.querySelector(`.node[data-index="${GameState.currentTown}"]`);
  if (!node) return;

  // Get town center in map coordinates
  const nodeRect = node.getBoundingClientRect();
  const mapRect = UI.map.getBoundingClientRect();
  const centerX = nodeRect.left - mapRect.left + nodeRect.width / 2;
  const centerY = nodeRect.top - mapRect.top + nodeRect.height / 2;

  // Inner circle radius (smaller than town circle)
  const total = GameState.players.length;
  const radius = 10; // small circle within the town

  GameState.players.forEach((p, i) => {
    let x = centerX;
    let y = centerY;

    if (total > 1) {
      const angle = (i / total) * 2 * Math.PI;
      // Distribute them slightly around the center so they don't overlap
      x += radius * Math.cos(angle);
      y += radius * Math.sin(angle);
    }

    p.dotEl.style.left = `${x}px`;
    p.dotEl.style.top = `${y}px`;
  });
}

document.getElementById("addPlayerBtn").onclick=()=>{
  addPlayer(document.getElementById("newPlayerName").value,false);
  document.getElementById("newPlayerName").value="";
};
document.getElementById("addAIPlayerBtn").onclick=()=>{
  addPlayer("Robot"+(GameState.players.length+1),true);
};

document.getElementById("startBtn").onclick = () => {
  if (GameState.players.length === 0) return UI.log("Add players first!");
  GameState.started = true;
  UI.log("üéÆ Game started!");
  UI.highlightActivePlayer();
  UI.refreshTable();

  // üöÄ If first player is AI, start its turn automatically
  const first = GameState.players[GameState.activeIndex];
  if (first.isAI) aiTakeTurn(first);
};

document.getElementById("resetBtn").onclick=()=>location.reload();

/* =========================================
   MODULE 6: AI Trader Pro ü§ñüí∞ (SMART VERSION)
   - Waits 2s before decision
   - Groups all robot logs into one elegant notification
   - Caravan moves only after all players finish
   ========================================= */
function aiTakeTurn(p) {
  // üß† Start thinking phase
  UI.log(`ü§ñ ${p.name} is analyzing market trends... (thinking...)`);
  Notifications.aiLog(`ü§ñ ${p.name} is analyzing market trends...`);

  setTimeout(() => {
    const price = GameState.prices[GameState.currentTown];
    const townName = GameState.towns[GameState.currentTown];

    // üó∫Ô∏è Log AI‚Äôs situational awareness
    if (typeof lastMovedTown === "undefined") {
      UI.log(`ü§ñ ${p.name} starts analysis at ${townName}.`);
      Notifications.aiLog(`üìç Starting analysis in ${townName}.`);
    } else if (lastMovedTown === GameState.currentTown) {
      UI.log(`ü§ñ ${p.name} notices caravan still in ${townName}.`);
      Notifications.aiLog(`üìç Caravan still in ${townName}.`);
    }

    lastMovedTown = GameState.currentTown;

    const gold = p.gold;
    const camels = p.camels;

    // üê™ Buying strategy
    if (price < 10 && gold >= price) {
      const budgetFactor = (10 - price) / 10;
      let spendAmount = gold * budgetFactor;
      if (price === 1) spendAmount = gold * 0.95;
      const n = Math.max(1, Math.floor(spendAmount / price));

      PlayerActions.buy(p, n);
      UI.log(`ü§ñ ${p.name} found a cheap market ($${price}) and bought ${n} camels.`);
      Notifications.aiLog(`üü¢ Cheap market ($${price}) ‚Äî bought ${n} camels.`);
    }

    // üí∞ Selling strategy
    else if (price >= 70 && camels > 0) {
      const avg = camels ? (p.totalSpent / camels) : 0;
      const profitRatio = price / (avg || 1);
      let n = 0;

      if (price >= 90) {
        n = camels;
        PlayerActions.sell(p, n);
        UI.log(`ü§ñ ${p.name} sees premium prices! Selling ALL camels at $${price}.`);
        Notifications.aiLog(`üíé Premium market ($${price}) ‚Äî sold ALL ${n} camels.`);
      } else if (profitRatio >= 1.2) {
        n = Math.ceil(camels * 0.6);
        PlayerActions.sell(p, n);
        UI.log(`ü§ñ ${p.name} takes profits and sells ${n} camels at $${price}.`);
        Notifications.aiLog(`üí∞ Profitable market ‚Äî sold ${n} camels.`);
      } else {
        n = Math.ceil(camels * 0.3);
        PlayerActions.sell(p, n);
        UI.log(`ü§ñ ${p.name} sells ${n} camels cautiously at $${price}.`);
        Notifications.aiLog(`‚öñÔ∏è Mild profit ‚Äî sold ${n} camels cautiously.`);
      }
    }

    // ü§î Waiting strategy
    else {
      UI.log(`ü§ñ ${p.name} decides to WAIT for a better opportunity.`);
      Notifications.aiLog(`‚è≥ Waits for better prices.`);
    }

    // ‚úÖ Finalize AI summary
    Notifications.aiLog("", true);

    // üßæ Refresh player info and proceed to next turn

UI.refreshTable();
GameFlow.playerActed();   // ‚úÖ Ÿäÿ≥ÿ¨ŸëŸÑ ÿßŸÑŸÅÿπŸÑ ÿ®ÿØŸÑ ŸÖÿß Ÿäÿ®ÿØŸëŸÑ ÿßŸÑÿØŸàÿ± ŸÅŸàÿ±Ÿãÿß
  }, 4000);
}

/* =========================================
   MODULE 7: Smart Single-Line Notifications (Map)
   ========================================= */
const Notifications = (function () {
  let el = null;
  let aiBuffer = "";
  let showing = false;
  let hideTimer = null;

  // üß± Ensure notification element exists
  function ensure() {
    if (el) return;
    el = document.createElement("div");
    el.id = "smart-notif";
    el.setAttribute("role", "status");
    el.setAttribute("aria-live", "polite");
    el.style.pointerEvents = "none";

    // Attach inside the map (or fallback to body)
    const map = document.querySelector(".map");
    if (map) map.appendChild(el);
    else document.body.appendChild(el);

    // üíÖ Shimmer style
    const s = document.createElement("style");
    s.textContent = `
#smart-notif {
  position: absolute;
  bottom: 5px;
  left: 10px;
  z-index: 1000;
  pointer-events: none;
  font-family: system-ui, sans-serif;
  font-weight: 500;
  font-size: 14px;
  letter-spacing: 0.4px;
  white-space: nowrap;
  text-align: left;
  opacity: 0;
  -webkit-font-smoothing: antialiased;

  background: linear-gradient(90deg, #ffffff, #ffd166, #7be57b, #ffffff);
  background-size: 300%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: hueShift 6s linear infinite;

  transition: opacity 0.35s ease, transform 0.35s ease;
  text-shadow: 0 2px 10px rgba(0,0,0,0.45);
}

#smart-notif.visible {
  opacity: 1;
  transform: translateY(-6px);
}

#smart-notif:not(.visible) {
  transform: translateY(10px);
}

@keyframes hueShift {
  0%   { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}`;
    document.head.appendChild(s);
  }

  // üîî Gentle chime sound
  function playChime() {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 880;
      gain.gain.value = 0.06;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.25);
    } catch (e) { /* silent fail */ }
  }

  // üß† Smart Replace Notification System
  function show(msg, opts = {}) {
    ensure();
    if (!msg) return;

    const level = opts.level || "info";
    const duration = opts.duration || (level === "important" ? 4200 : 2500);
    const sound = opts.sound ?? (level === "important");

    // If already showing ‚Üí fade out first, then show new
    if (showing) {
      el.classList.remove("visible");
      clearTimeout(hideTimer);
      setTimeout(() => displayNow(msg, duration, sound), 200);
    } else {
      displayNow(msg, duration, sound);
    }
  }

  function displayNow(msg, duration, sound) {
    showing = true;
    el.textContent = msg;
    el.classList.add("visible");
    if (sound) playChime();

    hideTimer = setTimeout(() => {
      el.classList.remove("visible");
      setTimeout(() => {
        el.textContent = "";
        showing = false;
      }, 300);
    }, duration);
  }

  // ü§ñ AI message grouping (summarized)
  function aiLog(line, done = false) {
    if (line && line.trim()) {
      if (aiBuffer) aiBuffer += " ¬∑ ";
      aiBuffer += line.trim().replace(/\s+/g, " ");
      if (aiBuffer.length > 160) aiBuffer = aiBuffer.slice(0, 157) + "‚Ä¶";
    }
    if (done && aiBuffer) {
      show(aiBuffer, { level: "good", duration: 5200 });
      aiBuffer = "";
    }
  }

  return { show, aiLog };
})();
/* =========================================
   ‚è≥ Enhanced Caravan Flow with Dice Delay
   ========================================= */
GameFlow.moveCaravan = function () {
  // üé≤ Roll two dice
  const g = this.rollDie();
  const r = this.rollDie();

  // Animate dice
  UI.greenDie.textContent = g;
  UI.redDie.textContent = r;
  UI.greenDie.classList.add("roll");
  UI.redDie.classList.add("roll");
  setTimeout(() => {
    UI.greenDie.classList.remove("roll");
    UI.redDie.classList.remove("roll");
  }, 400);

  // üßÆ Calculate movement direction
  const diff = Math.abs(g - r);
  let directionText, newIndex = GameState.currentTown;

  if (g > r) {
    directionText = `‚¨ÜÔ∏è Move UP ${diff} step${diff > 1 ? "s" : ""}`;
    newIndex = Math.min(GameState.towns.length - 1, GameState.currentTown + diff);
  } else if (r > g) {
    directionText = `‚¨áÔ∏è Move DOWN ${diff} step${diff > 1 ? "s" : ""}`;
    newIndex = Math.max(0, GameState.currentTown - diff);
  } else {
    directionText = "‚öñÔ∏è Equal dice! Caravan stays still.";
  }

  // ü™Ñ Show results before moving
  const msg = `üé≤ Dice rolled ‚Üí Green: ${g}, Red: ${r}. ${directionText}`;
  UI.log(msg);
  if (typeof Notifications !== "undefined") Notifications.show(msg);

  // üïí Wait 3 seconds before actual movement
  setTimeout(() => {
    if (newIndex !== GameState.currentTown) {
      GameState.currentTown = newIndex;
      const newTown = GameState.towns[newIndex];
      UI.log(`üê™ Caravan arrived at ${newTown}`);
      if (typeof Notifications !== "undefined") Notifications.show(`üê™ Caravan reached ${newTown}`);
      UI.updateTown();
      UI.refreshTable();
      positionPlayers();
      UI.highlightActivePlayer();
    }
  }, 3000);
};



/* =========================================
   MODULE: Dynamic Map + Sidebar Resizer
   ========================================= */
(function() {
  const container = document.querySelector(".container");
  const map = document.querySelector(".map");
  const sidebar = document.querySelector(".sidebar");

  // üß± Fix spacing
  container.style.display = "flex";
  container.style.gap = "0";
  container.style.alignItems = "flex-start";

  // ü™Ñ Create drag handle
  const handle = document.createElement("div");
  handle.id = "resizeHandle";
  handle.style.width = "8px";
  handle.style.cursor = "ew-resize";
  handle.style.background = "linear-gradient(180deg, #d6b370, #b87b2c)";
  handle.style.borderLeft = "2px solid #7a4f1a";
  handle.style.borderRight = "2px solid #7a4f1a";
  handle.style.height = "100%";
  handle.style.boxShadow = "inset 0 0 5px rgba(0,0,0,0.3)";
  container.insertBefore(handle, sidebar);

  // üñ±Ô∏è Handle drag logic
  let dragging = false;
  handle.addEventListener("mousedown", () => dragging = true);
  window.addEventListener("mouseup", () => dragging = false);
  window.addEventListener("mousemove", e => {
    if (!dragging) return;
    const rect = container.getBoundingClientRect();
    let newWidth = e.clientX - rect.left;
    newWidth = Math.max(400, Math.min(1100, newWidth)); // limit
    map.style.width = newWidth + "px";
  });

  // üß≠ Optional: Adjust sidebar to fill rest
  sidebar.style.flex = "1";
})();




init();
</script>
<script src="musicControl.js"></script>
</body>
</html>
