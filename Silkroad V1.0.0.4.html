
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Grand Silk Road ‚Äî by mO</title>
<style>

/* =========================================
   üé® STYLE SYSTEM
   ========================================= */
:root {
--map-width: 900px;   /* wider map */
--map-height: 1000px; /* shorter map */
  --gold: #ffcc00;
  --brown: #8a5930;
  --sand: #f7eed8;
}
body {
  font-family: system-ui, sans-serif;
  margin: 14px;
  background: var(--sand);
  color: #2b2b2b;
}
.container {
  display: flex;
  gap: 16px;
  align-items: flex-start;
}
.map {
  width: var(--map-width);
  height: var(--map-height);
  position: relative;
  background: url("Silkroad_page-0001.jpeg") no-repeat center center / cover;
  border: 10px solid var(--brown);
  border-radius: 12px;
  overflow: hidden;
}

/* ‚ú® Modern Caravan Entry Styling */
.login-panel {
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(18px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.25);
  border-radius: 14px;
  padding: 20px;
  box-shadow: 0 8px 28px rgba(0,0,0,0.25);
  text-align: center;
  color: #5b3a00;
  transition: all 0.6s ease;
}
.login-panel h2 {
  font-size: 20px;
  font-weight: 700;
  color: #b8860b;
  text-shadow: 0 1px 2px #fff;
  margin-bottom: 12px;
}
.login-panel input {
  width: 90%;
  padding: 10px;
  font-size: 14px;
  border-radius: 8px;
  border: 1px solid #e0c080;
  background: #fffdf7;
  margin-bottom: 10px;
  outline: none;
  text-align: center;
}
.login-panel button {
  padding: 10px 14px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: 600;
  transition: transform 0.2s ease, background 0.3s ease;
}
.login-panel button:hover { transform: scale(1.05); }
.login-panel .primary {
  background: linear-gradient(90deg, #ffcc00, #ffaa00);
  color: #3a2500;
}
.login-panel .ai {
  background: linear-gradient(90deg, #89f7fe, #66a6ff);
  color: #003366;
}
.login-panel .reset {
  background: linear-gradient(90deg, #ff4d4d, #b30000);
  color: #fff;
}
.hidden-panel { opacity: 0; transform: scale(0.9); pointer-events: none; }


/* =============================
   üó∫Ô∏è Town Nodes (Swapped Layout)
   ============================= */

/* ÿØÿßÿ¶ÿ±ÿ© ÿßŸÑŸÖÿØŸäŸÜÿ© (ÿßŸÑÿ≥ÿπÿ± ŸÅŸä ÿßŸÑŸÖŸÜÿ™ÿµŸÅ) */
.node {
  position: absolute;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  border: 3px solid rgba(0, 0, 0, 0.5);
  background: linear-gradient(#fff7e8, #f1d9b1);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.25);
  overflow: visible;
}

/* ÿßŸÑÿ≥ÿπÿ± ÿØÿßÿÆŸÑ ÿßŸÑÿØÿßÿ¶ÿ±ÿ© */
.node .price-main {
  font-size: 13px;
  font-weight: 800;
  color: #b8860b;
  position: relative;
  z-index: 2;
}

/* ÿßÿ≥ŸÖ ÿßŸÑŸÖÿØŸäŸÜÿ© ÿ™ÿ≠ÿ™ ÿßŸÑÿØÿßÿ¶ÿ±ÿ© ŸÖÿ®ÿßÿ¥ÿ±ÿ© */
.node .town-small {
  position: absolute;
  bottom: -18px;       /* ÿßŸÑŸÖÿ≥ÿßŸÅÿ© ÿ®ŸäŸÜ ÿßŸÑÿßÿ≥ŸÖ ŸàÿßŸÑÿØÿßÿ¶ÿ±ÿ© */
  left: 50%;
  transform: translateX(-50%);
  font-size: 9.5px;
  color: #fff;
  font-weight: 600;
  text-shadow: 0 1px 3px rgba(0,0,0,0.6);
  white-space: nowrap;
  pointer-events: none;
}

/* Highlighted current town */
.town-current {
  animation: flashInner 1.5s ease-in-out infinite alternate;
  border-color: var(--gold);
}

@keyframes flashInner {
  0% {
    background: linear-gradient(#fff7e8, #f1d9b1);
  }
  100% {
    background: var(--gold);
  }
}

/* üßç Player markers on map */
.player-dot {
  position: absolute;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  border: 2px solid #fff;
  transform: translate(-50%, -50%);
  z-index: 50; /* ‚úÖ Above town nodes (which use z-index: 10) */
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.4); /* subtle floating shadow */
  transition: left 1s linear, top 1s linear;
}

/* üîÜ Active player glowing effect */
.player-dot.active {
  animation: dotFlash 1.5s ease-in-out infinite alternate;
}

@keyframes dotFlash {
  0% {
    box-shadow: 0 0 6px 2px currentColor, 0 0 10px rgba(255, 255, 255, 0.6);
    transform: scale(1);
  }
  100% {
    box-shadow: 0 0 16px 8px currentColor, 0 0 14px rgba(255, 255, 255, 0.8);
    transform: scale(1.3);
  }
}

/* ‚ú® Transparent glass sidebar panel background */
.sidebar {
  width: 460px;
  background: rgba(255, 255, 255, 0.1); /* subtle white transparency */
  backdrop-filter: blur(18px) saturate(180%);
  border-radius: 12px;
  padding: 12px;
  box-shadow: 0 8px 28px rgba(0, 0, 0, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.25);
}

/* ü™∂ Transparent game log area */
#log {
  max-height: 180px;
  overflow: auto;
  font-size: 13px;
  padding: 8px;
  border-radius: 6px;
  background: rgba(255, 255, 255, 0.08); /* light transparent tint */
  backdrop-filter: blur(10px) saturate(160%);
  border: 1px solid rgba(255, 255, 255, 0.25);
  color: #2b2b2b;
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.1);
}

button {
  padding: 8px 10px;
  border-radius: 6px;
  border: 1px solid rgba(0, 0, 0, 0.08);
  background: #fff;
  cursor: pointer;
}
button.primary { background: #2e77ff; color: #fff; border: none; }
input { padding: 6px; border-radius: 6px; border: 1px solid #ccc; }
table { width: 100%; border-collapse: collapse; }
th, td { padding: 6px 8px; border-bottom: 1px solid #f2f2f2; font-size: 13px; text-align:center;}
th { background: #fbfbfb; font-weight: 600; }
#turnBanner {
  text-align:center; padding:8px; background:#ffe599;
  border-radius:6px; font-weight:700; color:#5b3a00;
  animation: blink 2s infinite;
}
@keyframes blink {0%,100%{opacity:1;}50%{opacity:0.6;}}

/* Small colored dot beside player name */
.player-dot-inline {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1px solid #fff;
  box-shadow: 0 0 2px rgba(0,0,0,0.4);
  margin-right: 6px;
  vertical-align: middle;
  transition: all 0.3s ease;
}

/* Flashing/glowing effect for active player */
.player-dot-inline.active {
  box-shadow: 0 0 12px 4px var(--gold);
  animation: flash 1.2s infinite alternate;
}

@keyframes flash {
  0% { opacity: 1; transform: scale(1); }
  100% { opacity: 0.6; transform: scale(1.3); }
}

/* üé≤ Dice area */
.dice-display {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 10px;
  background: #fff8dc;
  padding: 12px 0;
  border-radius: 8px;
  border: 2px solid #b8860b;
  margin-top: 12px;
}

.dice {
  background: radial-gradient(circle at 30% 30%, #fff, #ccc);
  border: 2px solid #444;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3), inset 0 0 6px rgba(0,0,0,0.2);
  width: 50px;
  height: 50px;
  border-radius: 10px;
  font-size: 26px;
  font-weight: 700;
  line-height: 46px;
  text-align: center;
  border: 2px solid #000;
  transition: transform 0.4s ease;
}

.dice.green {
  background: #e8ffe8;
  color: #007f00;
  border-color: #007f00;
}

.dice.red {
  background: #ffe8e8;
  color: #b00000;
  border-color: #b00000;
}

.dice.roll { transform: rotate(360deg); }

#currentTownText {
  font-size: 16px;
  font-weight: 600;
  color: #4b2e05;
  line-height: 1.7;
  text-align: center;
}

/* ‚ú® Flashing effects */
.town-name {
  color: #b22222;
  font-weight: 800;
  animation: flashTown 1.5s infinite alternate;
}

.price-flash {
  color: #d4a017;
  font-weight: 800;
  animation: flashPrice 1.2s infinite alternate;
}

@keyframes flashTown {
  0% { color: #b22222; text-shadow: 0 0 2px #ff9999; opacity: 0.8; }
  100% { color: #ff2d2d; text-shadow: 0 0 10px #ff6666; opacity: 1; }
}
@keyframes flashPrice {
  0% { color: #d4a017; text-shadow: 0 0 2px #ffd966; opacity: 0.8; }
  100% { color: #ffcc00; text-shadow: 0 0 10px #ffe066; opacity: 1; }
}

/* üé® Player Cards */
.players-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.player-card {
  border: 3px solid #ccc;
  border-radius: 10px;
  background: #fff;
  padding: 8px 10px;           /* tighter spacing */
  width: 180px;                /* card width */
  min-height: 90px;            /* ensure consistency */
  margin: 6px auto;            /* center inside list */
  box-shadow: 0 3px 8px rgba(0,0,0,0.1);
  transition: transform 0.2s ease, background 0.3s, box-shadow 0.3s ease;
  filter: grayscale(0.4);
  opacity: 0.9;
}

.player-card:hover {
  transform: scale(1.04);
  box-shadow: 0 4px 14px rgba(0,0,0,0.15);
}

.player-card.active {
  border-color: var(--gold);
  background: #fffbe6;
  filter: none;
  opacity: 1;
  animation: playerGlow 1.6s ease-in-out infinite alternate;
}

.player-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
  font-weight: 700;
  font-size: 14px;
}

.player-info {
  display: grid;
  grid-template-columns: 1fr 1fr;
  row-gap: 6px;
  column-gap: 10px;
  font-size: 13px;
}

.player-info div {
  display: flex;
  align-items: center;
  gap: 6px;
}

.player-info span.icon {
  font-size: 16px;
}

/* Glow pulse using player's color */
@keyframes playerGlow {
  0% { box-shadow: 0 0 0px rgba(255, 255, 255, 0.3); }
  100% { box-shadow: 0 0 20px 8px currentColor; }
}

/* üåà Flashing player dot */
.player-dot.active {
  animation: dotFlash 1.5s ease-in-out infinite alternate;
}
@keyframes dotFlash {
  0% { box-shadow: 0 0 4px 2px currentColor; transform: scale(1); }
  100% { box-shadow: 0 0 16px 8px currentColor; transform: scale(1.3); }
}
 

const style = document.createElement("style");
style.textContent = `
.notifications-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  z-index: 99999;
  pointer-events: none;
}

.notification {
  background: rgba(255, 255, 255, 0.12);
  backdrop-filter: blur(14px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.25);
  border-radius: 18px;
  padding: 12px 22px;
  font-size: 16px;
  font-weight: 600;
  color: #fff;
  text-align: center;
  letter-spacing: 0.3px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.35);
  animation: toastIn 0.4s ease-out forwards, toastOut 0.8s ease-in 4.5s forwards;
}

@keyframes toastIn {
  from { opacity: 0; transform: translateY(30px) scale(0.95); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

@keyframes toastOut {
  from { opacity: 1; transform: translateY(0) scale(1); }
  to { opacity: 0; transform: translateY(40px) scale(0.9); }
}
`;
document.head.appendChild(style);



/* üåü Main buttons */
.trade-controls button {
  padding: 8px 16px;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 700;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

.trade-controls button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

/* Button colors */
#buyBtn {
  background: linear-gradient(90deg, #4caf50, #2e7d32);
}
#sellBtn {
  background: linear-gradient(90deg, #e53935, #b71c1c);
}
#waitBtn {
  background: linear-gradient(90deg, #ffb300, #f57c00);
}

.inline-buttons {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.inline-buttons input {
  width: 55px;
  padding: 4px 6px;
  border-radius: 6px;
  border: 1px solid #d2a05a;
  text-align: center;
  font-size: 13px;
}

.inline-buttons button {
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 600;
  color: #fff;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
}

.inline-buy { background: linear-gradient(90deg, #4caf50, #2e7d32); }
.inline-sell { background: linear-gradient(90deg, #e53935, #b71c1c); }
.inline-wait { background: linear-gradient(90deg, #ffb300, #f57c00); }

.inline-buttons button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* =======================
   üßç Enhanced Player Card Layout
   ======================= */

.player-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-weight: 700;
  font-size: 14px;
  color: inherit;
}

.turn-status {
  font-size: 12px;
  color: var(--gold);
  animation: blink 1.2s infinite;
}
@keyframes blink {
  0%,100%{opacity:1;}50%{opacity:0.4;}
}

.player-divider {
  border: none;
  border-bottom: 1px dashed rgba(0,0,0,0.2);
  margin: 4px 0 6px;
}

.player-info-grid {
  display: flex;
  justify-content: space-between;
  font-size: 13px;
  margin-bottom: 6px;
}

/* üéÆ Inline trade area */
.inline-buttons {
  display: flex;
  align-items: center;
  justify-content: space-around;
  gap: 4px;
  margin-top: 6px;
}

.number-input {
  display: flex;
  align-items: center;
  border: 1px solid #d2a05a;
  border-radius: 6px;
  overflow: hidden;
  width: 60px;
  height: 26px;
  background: #fffbe9;
}

.number-input input {
  border: none;
  width: 32px;
  text-align: center;
  font-size: 12px;
  outline: none;
  background: transparent;
}

.num-btn {
  background: #ffefc1;
  border: none;
  font-size: 14px;
  width: 20px;
  height: 26px;
  cursor: pointer;
  transition: background 0.2s;
}
.num-btn:hover {
  background: #ffe08a;
}

/* keep the buttons aligned nicely */
.inline-buy, .inline-sell, .inline-wait {
  padding: 5px 8px;
  font-size: 12px;
  flex: 1;
  border-radius: 6px;
  font-weight: 600;
  color: #fff;
  text-shadow: 0 1px 1px rgba(0,0,0,0.3);
}

</style>
</head>






<body>

<div class="container">
  <div class="map" id="map"></div>

  <div class="sidebar"> 
 </div>
    <div class="panel">

<!-- ‚ú® Floating Sign-In Panel -->
<div class="login-floating" id="loginPanel">
  <h2>üèïÔ∏è Caravan Entry</h2>
  <input id="newPlayerName" type="text" placeholder="Player name..." />
  <div class="btns">
    <button id="addPlayerBtn">Add a player</button>
    <button id="addAIPlayerBtn" class="ai">Robot ü§ñ</button>
    <button id="startBtn" class="primary"> Start </button>
  </div>
  <button id="resetBtn" class="reset">‚ü≥</button>
</div>

<!-- ü™Ñ After Start (Mini Floating Glass Panel) -->
<div class="after-start-floating hidden-panel" id="afterStartPanel">
  <button id="resetBtn2" class="primary">üåü Start a new game</button>
</div>

<style>
/* ‚ú® Mini floating "Start a new game" badge */
.after-start-floating {
  position: absolute;
  top: 40px;
  right: 35px;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(18px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.25);
  border-radius: 12px;
  padding: 8px 10px;
  box-shadow: 0 4px 14px rgba(0,0,0,0.25);
  transition: all 0.5s ease;
  z-index: 999;
}
.after-start-floating button.primary {
  background: linear-gradient(90deg, #ffcc00, #ffaa00);
  color: #3a2500;
  border: none;
  font-size: 12px;
  font-weight: 700;
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s ease, background 0.3s ease;
}
.after-start-floating button.primary:hover {
  transform: scale(1.05);
}
.hidden-panel {
  opacity: 0;
  transform: scale(0.85);
  pointer-events: none;
}

/* üíé Floating Glass Sign-In Box (Centered on Map) */
.login-floating {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* ‚úÖ center perfectly */
  width: 260px;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(18px) saturate(180%);
  border: 1px solid rgba(255, 255, 255, 0.25);
  border-radius: 14px;
  padding: 16px 18px;
  box-shadow: 0 8px 28px rgba(0,0,0,0.25);
  text-align: center;
  color: #4b2e05;
  z-index: 999;
  transition: all 0.6s ease;
}

.login-floating h2 {
  font-size: 16px;
  font-weight: 700;
  color: #b8860b;
  margin-bottom: 10px;
  text-shadow: 0 1px 2px #fff;
}

.login-floating input {
  width: 90%;
  padding: 8px;
  font-size: 13px;
  border-radius: 6px;
  border: 1px solid #e0c080;
  background: #fffdf7;
  margin-bottom: 8px;
  text-align: center;
  outline: none;
}

.login-floating .btns {
  display: flex;
  justify-content: space-between;
  gap: 6px;
  margin-bottom: 6px;
}

.login-floating button {
  flex: 1;
  padding: 6px 8px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  font-size: 12px;
  font-weight: 600;
  transition: transform 0.2s ease, background 0.3s ease;
}

.login-floating button:hover {
  transform: scale(1.05);
}

.login-floating .primary {
  background: linear-gradient(90deg, #ffcc00, #ffaa00);
  color: #3a2500;
}

.login-floating .ai {
  background: linear-gradient(90deg, #89f7fe, #66a6ff);
  color: #003366;
}

.login-floating .reset {
  background: linear-gradient(90deg, #ff4d4d, #b30000);
  color: #fff;
  width: 100%;
  margin-top: 4px;
}

.hidden-panel {
  opacity: 0;
  transform: scale(0.85);
  pointer-events: none;
}

</style>

<script>
/* üß≠ Keep the hide/show logic */
document.getElementById("startBtn").addEventListener("click", () => {
  const loginPanel = document.getElementById("loginPanel");
  const afterStartPanel = document.getElementById("afterStartPanel");
  setTimeout(() => {
    loginPanel.classList.add("hidden-panel");
    afterStartPanel.classList.remove("hidden-panel");
  }, 600);
});
document.getElementById("resetBtn2").onclick = () => location.reload();
</script>

<script>
/* üîÅ Hide floating sign-in after Start */
document.getElementById("startBtn").addEventListener("click", () => {
  const loginPanel = document.getElementById("loginPanel");
  const afterStartPanel = document.getElementById("afterStartPanel");
  setTimeout(() => {
    loginPanel.classList.add("hidden-panel");
    afterStartPanel.classList.remove("hidden-panel");
  }, 600);
});
document.getElementById("resetBtn2").onclick = () => location.reload();
</script>

    <div class="panel">

<br/> <br/> <br/>

      <strong></strong>
<br/> <br/>

      <strong></strong>

      <div id="currentTownText"> üèôÔ∏è price: </div><br/>

      <div id="turnBanner">Waiting for players...</div><br/>

    <div class="panel">


      <strong>Players <br/> <br/> </strong>

<div id="playersTableContainer" class="players-container"></div>

    </div>

      <strong>Dice</strong>
      <div class="dice-display">
        <div class="dice" id="greenDie">-</div>
        <div class="dice" id="redDie">-</div>
      </div>
<br/>
    <div class="panel">
      <strong>Log</strong>

<div id="log"></div>

    </div>
  </div>
</div>

<script>


/* üîÅ Hide login panel after start */
document.getElementById("startBtn").addEventListener("click", () => {
  const loginPanel = document.getElementById("loginPanel");
  const afterStartPanel = document.getElementById("afterStartPanel");
  setTimeout(() => {
    loginPanel.classList.add("hidden-panel");
    afterStartPanel.classList.remove("hidden-panel");
  }, 600);
});
document.getElementById("resetBtn2").onclick = () => location.reload();

/* =========================================
   MODULE 1: Game State
   ========================================= */
const GameState = {
  towns: ["Tianlu","Ozon","Daruk","Samurai","Turkhan","Marzban","Seraphis","Tsafir","Nimar","Valon","Zemara","Artava","Azharan","Qashim","Liavera","Oravan","Novar","Shariza","Gate of Dusk"],
  prices: [1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100],
  players: [],
  activeIndex: 0,
  currentTown: 9,
  started: false,
  palette: ["#ff4d4d","#34c759","#007aff","#ff9500","#af52de","#5ac8fa"]
};

/* =========================================
   MODULE 2: UI
   ========================================= */
const UI = {
  map: document.getElementById("map"),
  logBox: document.getElementById("log"),
  townText: document.getElementById("currentTownText"),
  greenDie: document.getElementById("greenDie"),
  redDie: document.getElementById("redDie"),
  turnBanner: document.getElementById("turnBanner"),

  log(msg) {
    const div = document.createElement("div");
    div.textContent = msg;
    this.logBox.prepend(div);

    // üîî Floating notification
    if (typeof Notifications !== "undefined") {
      Notifications.show(msg);
    }
  },

  updateTown() {
    const i = GameState.currentTown;
    const townName = GameState.towns[i];
    const price = GameState.prices[i];

    this.townText.innerHTML = `
      üèôÔ∏è You are in 
      <span class="town-name">${townName}</span> City &nbsp;&nbsp;
      <br>üê™ Camel price 
      <span class="price-flash">$${price}</span>
    `;

    document.querySelectorAll(".node").forEach(n => n.classList.remove("town-current"));
    const node = document.querySelector(`.node[data-index="${i}"]`);
    if (node) node.classList.add("town-current");
  },

townCoords: [
  [60, 82],  // Tianlu ($1) ‚Äî Bottom
  [55, 78],  // Ozon ($2)
  [50, 74],  // Daruk ($3)
  [45, 70],  // Samurai ($4)
  [40, 66],  // Turkhan ($5)
  [35, 62],  // Marzban ($6)
  [32, 58],  // Seraphis ($7)
  [38, 54],  // Tsafir ($8)
  [44, 50],  // Nimar ($9)
  [50, 46],  // Valon ($10)
  [45, 42],  // Zemara ($20)
  [40, 38],  // Artava ($30)
  [35, 34],  // Azharan ($40)
  [30, 30],  // Qashim ($50)
  [34, 26],  // Liavera ($60)
  [38, 22],  // Oravan ($70)
  [44, 18],  // Novar ($80)
  [50, 14],  // Shariza ($90)
  [56, 10],  // Gate of Dusk ($100) ‚Äî Top
],

  createNode(index, name, price) {
    const div = document.createElement("div");
    div.className = "node";
    div.dataset.index = index;
    div.innerHTML = `
      <div class="price-main">$${price}</div>
      <div class="town-small">${name}</div>
    `;

    // ÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™
    if (this.townCoords && this.townCoords[index]) {
      let [x, y] = this.townCoords[index];
      x = Math.max(0, Math.min(100, x));
      y = Math.max(0, Math.min(100, y));
      div.style.left = x + "%";
      div.style.top = y + "%";
    }

    div.style.position = "absolute";
    div.style.zIndex = 10;
    this.map.appendChild(div);
  },

refreshTable() {
  const container = document.querySelector("#playersTableContainer");
  if (!container) return;
  container.innerHTML = "";

  GameState.players.forEach((p, i) => {
    const avg = p.camels ? (p.totalSpent / p.camels).toFixed(1) : "-";
    const wealth = (p.gold + p.camels * GameState.prices[GameState.currentTown]).toFixed(1);

    const card = document.createElement("div");
    card.className = "player-card";
    if (i === GameState.activeIndex) card.classList.add("active");

    card.style.borderColor = p.color;
    card.style.background = `${p.color}15`;
    card.style.color = p.color;

card.innerHTML = `
  <div class="player-header">
    <div>
      <span class="player-dot-inline" style="background:${p.color}"></span>
      ${p.name} ${p.isAI ? "ü§ñ" : "üßç"}
    </div>
    <div class="turn-status">${i === GameState.activeIndex ? "üéØ Your Turn" : ""}</div>
  </div>

  <hr class="player-divider" />

  <div class="player-info-grid">
    <div><span class="icon">üê™</span> <strong>${p.camels}</strong> Camels</div>
    <div><span class="icon">üí≤</span> <strong>${p.gold}</strong> Gold</div>
  </div>
`;

    // ‚úÖ If it's this player's turn and not AI, show trade buttons
    if (i === GameState.activeIndex && !p.isAI && GameState.started) {
      const btnArea = document.createElement("div");
      btnArea.className = "inline-buttons";

btnArea.innerHTML = `
  <div class="number-input">
    <button class="num-btn minus">‚Äì</button>
    <input type="number" id="inlineCamelCount" value="1" min="1" />
    <button class="num-btn plus">+</button>
  </div>
  <button class="inline-buy">Buy</button>
  <button class="inline-sell">Sell</button>
  <button class="inline-wait">Wait</button>
`;

const input = btnArea.querySelector("#inlineCamelCount");
btnArea.querySelector(".plus").onclick = () => input.stepUp();
btnArea.querySelector(".minus").onclick = () => input.stepDown();

      card.appendChild(btnArea);

      // connect functionality
      const buy = btnArea.querySelector(".inline-buy");
      const sell = btnArea.querySelector(".inline-sell");
      const wait = btnArea.querySelector(".inline-wait");
      const countInput = btnArea.querySelector("#inlineCamelCount");

      const price = GameState.prices[GameState.currentTown];
      buy.disabled = (p.gold < price);
      sell.disabled = (p.camels <= 0);

      buy.onclick = () => {
        const n = +countInput.value;
        PlayerActions.buy(p, n);
        UI.refreshTable();
        GameFlow.playerActed();
      };
      sell.onclick = () => {
        const n = +countInput.value;
        PlayerActions.sell(p, n);
        UI.refreshTable();
        GameFlow.playerActed();
      };
      wait.onclick = () => {
        UI.log(`${p.name} waits.`);
        GameFlow.playerActed();
      };
    }

    container.appendChild(card);
  });
},

  highlightActivePlayer() {
    const active = GameState.players[GameState.activeIndex];
    this.turnBanner.textContent = `üéØ ${active.name}'s Turn ${active.isAI ? "(AI)" : ""}`;

    GameState.players.forEach((p, i) =>
      p.dotEl.classList.toggle("active", i === GameState.activeIndex)
    );

    const cards = document.querySelectorAll(".player-card");
    cards.forEach((card, i) => {
      card.classList.toggle("active", i === GameState.activeIndex);
    });

  }   // ‚úÖ close the function properly
};     // ‚úÖ close the whole UI object properly

/* =========================================
   MODULE 3: Player Actions
   ========================================= */
const PlayerActions={
  buy(p,n){
    const price=GameState.prices[GameState.currentTown];
    if(p.gold<price*n) return UI.log(`${p.name} can't afford that.`);
    p.gold-=price*n;
    p.camels+=n;
    p.totalSpent+=price*n;
    UI.log(`${p.name} bought ${n} camels at $${price}`);
  },
  sell(p,n){
    const price=GameState.prices[GameState.currentTown];
    if(p.camels<n) return UI.log(`${p.name} has not enough camels.`);
    const avg=p.camels?(p.totalSpent/p.camels):0;
    p.camels-=n;
    p.gold+=price*n;
    p.totalSpent-=avg*n;
    UI.log(`${p.name} sold ${n} camels at $${price}`);
  }
};

/* =========================================
   MODULE 4: Game Flow ‚Äî Round-based & synchronized dice
   - ŸÉŸÑ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ŸäÿÆÿ™ÿßÿ±Ÿàÿß ÿ£ŸàŸÑÿßŸãÿå ÿ´ŸÖ ŸÜÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ± ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ© ŸÑŸÑÿ¨ŸÖŸäÿπ
   - ŸäÿØŸäÿ± ÿßŸÑŸÄ turn progression ŸàÿßŸÑŸÄ caravan movement
   ========================================= */
const GameFlow = (function () {
  // private state
  let actionsTaken = 0;         // ŸÉŸÖ ŸÑÿßÿπÿ® ÿ£ŸÜŸáŸâ ÿßÿÆÿ™Ÿäÿßÿ±Ÿá ŸÅŸä ÿßŸÑŸÄ round ÿßŸÑÿ≠ÿßŸÑŸä
  let roundNumber = 1;

  return {
    // ŸÖÿπÿßŸÑÿ¨ Ÿäÿ≥ÿ™ÿÆÿØŸÖŸá ŸÉŸÑ ÿ≤ÿ±/AI ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑŸÑÿßÿπÿ® ŸÖŸÜ ÿπŸÖŸÑŸá
    // Ÿäÿ¨ÿ® ÿßÿ≥ÿ™ÿØÿπÿßÿ§Ÿá ÿ®ÿπÿØ ÿ™ŸÜŸÅŸäÿ∞ ÿπŸÖŸÑŸäÿ© (buy/sell/wait) ŸÑŸÑŸÑÿßÿπÿ® ÿßŸÑÿ≠ÿßŸÑŸä
    playerActed() {
      actionsTaken++;
      UI.log(`‚úÖ Action registered (${actionsTaken}/${GameState.players.length})`);
      // ŸÑŸà ŸÉŸÑ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿ£ŸÜŸáŸàÿß ‚Äî ŸÜŸÖÿ∂Ÿä ÿ•ŸÑŸâ ÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ± Ÿàÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÇÿßŸÅŸÑÿ©
      if (actionsTaken >= GameState.players.length) {
        actionsTaken = 0; // reset for next round
        roundNumber++;
        UI.log(`üîî All players acted ‚Äî rolling dice for round ${roundNumber}`);
        this.executeRoundMovement();
      }
      // ÿ®ÿπÿØ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÅÿπŸÑÿå ŸÜŸÜÿ™ŸÇŸÑ ŸÑŸÑŸëÿßÿπÿ® ÿßŸÑÿ™ÿßŸÑŸä (Ÿáÿ∞Ÿá ÿßŸÑŸàÿ∏ŸäŸÅÿ© ŸÑÿß ÿ™ÿ™ÿ≠ŸÉŸÖ ÿ®ÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ±)
      this.advanceActivePlayer();
    },

    // ÿßŸÑÿ™ŸÇÿØŸÖ ÿ•ŸÑŸâ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ™ÿßŸÑŸä (ŸÑÿß Ÿäÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ±)
    advanceActivePlayer() {
      GameState.activeIndex = (GameState.activeIndex + 1) % GameState.players.length;
      UI.refreshTable();
      UI.highlightActivePlayer();

      // ÿ•ÿ∞ÿß ÿßŸÑÿ™ÿßŸÑŸä AIÿå ÿßÿ∑ŸÑÿ® ŸÖŸÜŸá ÿßŸÑÿ™ŸÅŸÉŸäÿ±/ÿßŸÑÿ™ÿµÿ±ŸÅ ŸÉŸÖÿß ŸÇÿ®ŸÑÿßŸã
      const current = GameState.players[GameState.activeIndex];
      if (current && current.isAI) {
        // ŸÜÿ™ÿ±ŸÉ aiTakeTurn ŸÉŸÖÿß ŸáŸà ‚Äî ÿπŸÑŸäŸá ÿ£ŸÜ ŸäŸÜÿßÿØŸä playerActed() ÿ®ÿπÿØ ŸÇÿ±ÿßÿ±Ÿá
        aiTakeTurn(current);
      }
    },

    // ÿ∑ÿ±ŸäŸÇÿ© ŸÑÿ±ŸÖŸä ŸÜÿ±ÿØ (1..6)
    rollDie() {
      return Math.floor(Math.random() * 6) + 1;
    },

    // ÿ™ŸÜŸÅŸäÿ∞ ÿ±ŸÖŸä ÿßŸÑÿ≤Ÿáÿ± Ÿàÿßÿ∏Ÿáÿßÿ± ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿ´ŸÖ ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÇÿßŸÅŸÑÿ© ÿ®ÿπÿØ ŸÖŸáŸÑÿ© ŸÇÿµŸäÿ±ÿ©
    executeRoundMovement() {
      // üé≤ Roll
      const g = this.rollDie();
      const r = this.rollDie();

      // ÿπÿ±ÿ∂ ÿßŸÑÿ£ÿ±ŸÇÿßŸÖ ŸÅŸàÿ±Ÿãÿß (animation)
      UI.greenDie.textContent = g;
      UI.redDie.textContent = r;
      UI.greenDie.classList.add("roll");
      UI.redDie.classList.add("roll");
      setTimeout(() => {
        UI.greenDie.classList.remove("roll");
        UI.redDie.classList.remove("roll");
      }, 500);

      // ÿ™ÿ∑ÿ®ŸäŸÇ ŸÇŸàÿßÿπÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿÆÿßÿµ: ÿ™ÿ¨ÿßŸáŸÑ ÿ£ÿ≠ÿØ ÿßŸÑÿ£ŸÜŸàÿßÿπ ÿ≠ÿ≥ÿ® ÿßŸÑŸÖÿØŸäŸÜÿ©
      const currentPrice = GameState.prices[GameState.currentTown];
      let usedGreen = true, usedRed = true;

      if (currentPrice === 1) {
        usedRed = false; // ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿØŸÜ ÿ™ÿ≠ÿ™ -> ŸÑÿß ŸÜÿ£ÿÆÿ∞ ÿßŸÑÿ£ÿ≠ŸÖÿ±
        UI.log("‚ÑπÔ∏è At bottom city (price 1): Ignoring RED die.");
      } else if (currentPrice === 100) {
        usedGreen = false; // ŸÅŸä ÿßŸÑŸÇŸÖÿ© -> ŸÑÿß ŸÜÿ£ÿÆÿ∞ ÿßŸÑÿ£ÿÆÿ∂ÿ±
        UI.log("‚ÑπÔ∏è At top city (price 100): Ignoring GREEN die.");
      }

      // ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÅÿßÿ±ŸÇ ÿ£Ÿà ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑŸÅÿπŸÑŸäÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ≠ÿØÿØ ÿßŸÑÿ™ÿ≠ÿ±ŸÉ
      // ŸÖŸÜÿ∑ŸÇ: ÿ•ÿ∞ÿß ÿ£ÿ≠ÿØ ÿßŸÑŸÜÿ±ÿØŸäŸÜ ŸÖŸèŸáŸÖŸÑ ŸÜÿ≥ÿ™ÿÆÿØŸÖ ŸÇŸäŸÖÿ© ÿßŸÑÿ¢ÿÆÿ± (ŸÖŸÇÿØÿßÿ± ÿßŸÑÿ™ÿ≠ÿ±ŸÉ) Ÿàÿ®ÿßÿ™ÿ¨ÿßŸáŸá.
      // ÿ•ÿ∞ÿß ŸÉŸÑÿßŸáŸÖÿß ŸÖÿ≥ÿ™ÿÆÿØŸÖÿßŸÜÿå ŸÜÿ≠ÿ≥ÿ® ÿßŸÑŸÅÿ±ŸÇ (abs) ŸàŸÜÿ£ÿÆÿ∞ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿ≠ÿ≥ÿ® ÿßŸÑÿ£ŸÉÿ®ÿ±.
      let diff = 0;
      let direction = "none";
      if (usedGreen && !usedRed) {
        diff = g;
        direction = "green-only";
      } else if (!usedGreen && usedRed) {
        diff = r;
        direction = "red-only";
      } else if (usedGreen && usedRed) {
        if (g > r) { diff = g - r; direction = "up"; }
        else if (r > g) { diff = r - g; direction = "down"; }
        else { diff = 0; direction = "equal"; }
      }

      // üëÄ ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ŸÇÿ®ŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿ© ŸÑŸÖÿØÿ© ŸÇÿµŸäÿ±ÿ© ŸÉŸä Ÿäÿ≥ÿ™Ÿàÿπÿ® ÿßŸÑŸÑÿßÿπÿ®ŸàŸÜ
      let directionText = "";
      if (direction === "green-only") directionText = `‚¨ÜÔ∏è Move UP ${diff} step${diff>1?"s":""} (GREEN only)`;
      else if (direction === "red-only") directionText = `‚¨áÔ∏è Move DOWN ${diff} step${diff>1?"s":""} (RED only)`;
      else if (direction === "up") directionText = `‚¨ÜÔ∏è Move UP ${diff} step${diff>1?"s":""}`;
      else if (direction === "down") directionText = `‚¨áÔ∏è Move DOWN ${diff} step${diff>1?"s":""}`;
      else directionText = `‚öñÔ∏è No movement (equal dice).`;

      const resultMsg = `üé≤ Dice: Green ${g} | Red ${r} ‚Üí ${directionText}`;
      UI.log(resultMsg);
      if (typeof Notifications !== "undefined") Notifications.show(resultMsg, { level: "important", duration: 2000 });

      // ÿ®ÿπÿØ 2000ms ŸÜŸÜŸÅÿ∞ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÅÿπŸÑŸäÿ©
      setTimeout(() => {
        // ÿ•ÿ∞ÿß diff === 0 => ŸÑÿß ÿ≠ÿ±ŸÉÿ©
        if (diff <= 0) {
          UI.log("üê™ Caravan stays in place this round.");
          if (typeof Notifications !== "undefined") Notifications.show("üê™ Caravan stays in place.", { duration: 1800 });
          UI.updateTown();
          UI.refreshTable();
          positionPlayers();
          UI.highlightActivePlayer();
          return;
        }

        const prevIndex = GameState.currentTown;
        let newIndex = prevIndex;

        if (direction === "green-only" || direction === "up") {
          newIndex = Math.min(GameState.towns.length - 1, prevIndex + diff);
        } else if (direction === "red-only" || direction === "down") {
          newIndex = Math.max(0, prevIndex - diff);
        }

        // ÿ≥ÿ¨ŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿ© Ÿàÿ≠ÿØÿ´ ÿßŸÑŸàÿßÿ¨Ÿáÿ©
        if (newIndex !== prevIndex) {
          GameState.currentTown = newIndex;
          const newTown = GameState.towns[newIndex];
          UI.log(`üê™ Caravan moved ${diff} ‚Üí ${newTown}`);
          if (typeof Notifications !== "undefined") Notifications.show(`üê™ Caravan reached ${newTown}`, { level: "good", duration: 2400 });
        } else {
          UI.log("üê™ Caravan tried to move but reached boundary (stays).");
          if (typeof Notifications !== "undefined") Notifications.show("üê™ Caravan at map boundary ‚Äî stays.", { duration: 1800 });
        }

        UI.updateTown();
        UI.refreshTable();
        positionPlayers();
        UI.highlightActivePlayer();
      }, 2000); // 2s delay for player awareness
    },

    // expose for external calls if ever needed (read-only)
    getRoundNumber() { return roundNumber; },

    // helper: reset round counters (rarely needed externally)
    resetRound() {
      actionsTaken = 0;
      UI.log("üîÅ Round counters reset.");
    }
  };
})(); 

/* =========================================
   MODULE 5: Setup and Event Handlers
   ========================================= */
function init(){
  GameState.towns.forEach((t,i)=>UI.createNode(i,t,GameState.prices[i]));
  UI.updateTown();
  UI.log("‚úÖ Ready");
}

function addPlayer(name, isAI = false) {
  if (!name) return;
  const color = GameState.palette[GameState.players.length % GameState.palette.length];
  const p = {
    name,
    gold: 10,
    camels: 0,
    totalSpent: 0,
    isAI,
    color, // ‚úÖ store color for table use
    dotEl: document.createElement("div")
  };

  p.dotEl.className = "player-dot";
  p.dotEl.style.background = color;
  p.dotEl.style.color = color; // üÜï added line for glowing in player color

  GameState.players.push(p);
  UI.map.appendChild(p.dotEl);

  positionPlayers();
  UI.refreshTable();
  UI.log(`${name} joined ${isAI ? "(AI)" : ""}`);
}

function positionPlayers() {
  const node = document.querySelector(`.node[data-index="${GameState.currentTown}"]`);
  if (!node) return;

  // Get town center in map coordinates
  const nodeRect = node.getBoundingClientRect();
  const mapRect = UI.map.getBoundingClientRect();
  const centerX = nodeRect.left - mapRect.left + nodeRect.width / 2;
  const centerY = nodeRect.top - mapRect.top + nodeRect.height / 2;

  // Inner circle radius (smaller than town circle)
  const total = GameState.players.length;
  const radius = 10; // small circle within the town

  GameState.players.forEach((p, i) => {
    let x = centerX;
    let y = centerY;

    if (total > 1) {
      const angle = (i / total) * 2 * Math.PI;
      // Distribute them slightly around the center so they don't overlap
      x += radius * Math.cos(angle);
      y += radius * Math.sin(angle);
    }

    p.dotEl.style.left = `${x}px`;
    p.dotEl.style.top = `${y}px`;
  });
}

document.getElementById("addPlayerBtn").onclick=()=>{
  addPlayer(document.getElementById("newPlayerName").value,false);
  document.getElementById("newPlayerName").value="";
};
document.getElementById("addAIPlayerBtn").onclick=()=>{
  addPlayer("Robot"+(GameState.players.length+1),true);
};

document.getElementById("startBtn").onclick = () => {
  if (GameState.players.length === 0) return UI.log("Add players first!");
  GameState.started = true;
  UI.log("üéÆ Game started!");
  UI.highlightActivePlayer();
  UI.refreshTable();

  // üöÄ If first player is AI, start its turn automatically
  const first = GameState.players[GameState.activeIndex];
  if (first.isAI) aiTakeTurn(first);
};

document.getElementById("resetBtn").onclick=()=>location.reload();

/* =========================================
   MODULE 6: AI Trader Pro ü§ñüí∞ (SMART VERSION)
   - Waits 2s before decision
   - Groups all robot logs into one elegant notification
   - Caravan moves only after all players finish
   ========================================= */
function aiTakeTurn(p) {
  // üß† Start thinking phase
  UI.log(`ü§ñ ${p.name} is analyzing market trends... (thinking...)`);
  Notifications.aiLog(`ü§ñ ${p.name} is analyzing market trends...`);

  setTimeout(() => {
    const price = GameState.prices[GameState.currentTown];
    const townName = GameState.towns[GameState.currentTown];

    // üó∫Ô∏è Log AI‚Äôs situational awareness
    if (typeof lastMovedTown === "undefined") {
      UI.log(`ü§ñ ${p.name} starts analysis at ${townName}.`);
      Notifications.aiLog(`üìç Starting analysis in ${townName}.`);
    } else if (lastMovedTown === GameState.currentTown) {
      UI.log(`ü§ñ ${p.name} notices caravan still in ${townName}.`);
      Notifications.aiLog(`üìç Caravan still in ${townName}.`);
    }

    lastMovedTown = GameState.currentTown;

    const gold = p.gold;
    const camels = p.camels;

    // üê™ Buying strategy
    if (price < 10 && gold >= price) {
      const budgetFactor = (10 - price) / 10;
      let spendAmount = gold * budgetFactor;
      if (price === 1) spendAmount = gold * 0.95;
      const n = Math.max(1, Math.floor(spendAmount / price));

      PlayerActions.buy(p, n);
      UI.log(`ü§ñ ${p.name} found a cheap market ($${price}) and bought ${n} camels.`);
      Notifications.aiLog(`üü¢ Cheap market ($${price}) ‚Äî bought ${n} camels.`);
    }

    // üí∞ Selling strategy
    else if (price >= 70 && camels > 0) {
      const avg = camels ? (p.totalSpent / camels) : 0;
      const profitRatio = price / (avg || 1);
      let n = 0;

      if (price >= 90) {
        n = camels;
        PlayerActions.sell(p, n);
        UI.log(`ü§ñ ${p.name} sees premium prices! Selling ALL camels at $${price}.`);
        Notifications.aiLog(`üíé Premium market ($${price}) ‚Äî sold ALL ${n} camels.`);
      } else if (profitRatio >= 1.2) {
        n = Math.ceil(camels * 0.6);
        PlayerActions.sell(p, n);
        UI.log(`ü§ñ ${p.name} takes profits and sells ${n} camels at $${price}.`);
        Notifications.aiLog(`üí∞ Profitable market ‚Äî sold ${n} camels.`);
      } else {
        n = Math.ceil(camels * 0.3);
        PlayerActions.sell(p, n);
        UI.log(`ü§ñ ${p.name} sells ${n} camels cautiously at $${price}.`);
        Notifications.aiLog(`‚öñÔ∏è Mild profit ‚Äî sold ${n} camels cautiously.`);
      }
    }

    // ü§î Waiting strategy
    else {
      UI.log(`ü§ñ ${p.name} decides to WAIT for a better opportunity.`);
      Notifications.aiLog(`‚è≥ Waits for better prices.`);
    }

    // ‚úÖ Finalize AI summary
    Notifications.aiLog("", true);

    // üßæ Refresh player info and proceed to next turn

UI.refreshTable();
GameFlow.playerActed();   // ‚úÖ Ÿäÿ≥ÿ¨ŸëŸÑ ÿßŸÑŸÅÿπŸÑ ÿ®ÿØŸÑ ŸÖÿß Ÿäÿ®ÿØŸëŸÑ ÿßŸÑÿØŸàÿ± ŸÅŸàÿ±Ÿãÿß
  }, 4000);
}

/* =========================================
   MODULE 7: Smart Single-Line Notifications (Map Bottom-Left)
   - Elegant shimmer text anchored inside map
   - Soft fade + slide animation
   - Anti-spam + optional sound
   ========================================= */
const Notifications = (function () {
  let el = null;
  let hideTimer = null;
  let lastMsg = "";
  let lastShownAt = 0;
  let aiBuffer = "";

  function ensure() {
    if (el) return;
    el = document.createElement("div");
    el.id = "smart-notif";
    el.setAttribute("role", "status");
    el.setAttribute("aria-live", "polite");
    el.style.pointerEvents = "none";

    // üìç Attach inside the map (not the body)
    const map = document.querySelector(".map");
    if (map) map.appendChild(el);
    else document.body.appendChild(el); // fallback if map not found

    // üíÖ Inject floating shimmer CSS
    const s = document.createElement("style");
    s.textContent = `
#smart-notif {
  position: absolute;               /* anchored inside the map */
  top: 5px;                     /* distance from bottom of map */
  left: 10px;                       /* distance from left of map */
  z-index: 1000;
  pointer-events: none;
  font-family: system-ui, sans-serif;
  font-weight: 500;
  font-size: 14px;
  letter-spacing: 0.4px;
  white-space: nowrap;
  text-align: left;
  opacity: 0;
  -webkit-font-smoothing: antialiased;

  /* üåà shimmer gradient */
  background: linear-gradient(90deg, #ffffff, #ffd166, #7be57b, #ffffff);
  background-size: 300%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: hueShift 6s linear infinite;

  /* ‚ú® fade + float animation */
  transition: opacity 0.35s ease, transform 0.35s ease;
  text-shadow: 0 2px 10px rgba(0,0,0,0.45);
}

#smart-notif.visible {
  opacity: 1;
  transform: translateY(-6px);
}

#smart-notif:not(.visible) {
  transform: translateY(10px);
}

@keyframes hueShift {
  0%   { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}
    `;
    document.head.appendChild(s);
  }

  // üß† Hide text smoothly
  function hide() {
    if (!el) return;
    el.classList.remove("visible");
    setTimeout(() => { if (el) el.textContent = ""; }, 400);
  }

  // üîî Soft chime sound for key notifications
  function playChime() {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 880; // gentle tone
      gain.gain.value = 0.06;    // low volume
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.25);
    } catch (e) { /* silent fail */ }
  }

  // üó£Ô∏è Public method: show message
  function show(msg, opts = {}) {
    ensure();
    const now = Date.now();

    // üö´ Anti-spam: ignore rapid identical messages
    if (msg === lastMsg && now - lastShownAt < 700) return;

    lastMsg = msg;
    lastShownAt = now;

    const level = opts.level || "info";
    const duration = opts.duration || (level === "important" ? 5200 : 3200);
    const sound = opts.sound ?? (level === "important"); // only important plays by default

    el.textContent = msg;
    el.classList.add("visible");

    if (sound) playChime();

    if (hideTimer) clearTimeout(hideTimer);
    hideTimer = setTimeout(hide, duration);
  }

  // ü§ñ AI message grouping (combines many AI lines into one elegant line)
  function aiLog(line, done = false) {
    if (line && line.trim()) {
      if (aiBuffer) aiBuffer += " ¬∑ ";
      aiBuffer += line.trim().replace(/\s+/g, " ");
      if (aiBuffer.length > 160) aiBuffer = aiBuffer.slice(0, 157) + "‚Ä¶";
    }
    if (done && aiBuffer) {
      show(aiBuffer, { level: "good", duration: 5200 });
      aiBuffer = "";
    }
  }

  return { show, aiLog };
})();

/* =========================================
   ‚è≥ Enhanced Caravan Flow with Dice Delay
   ========================================= */
GameFlow.moveCaravan = function () {
  // üé≤ Roll two dice
  const g = this.rollDie();
  const r = this.rollDie();

  // Animate dice
  UI.greenDie.textContent = g;
  UI.redDie.textContent = r;
  UI.greenDie.classList.add("roll");
  UI.redDie.classList.add("roll");
  setTimeout(() => {
    UI.greenDie.classList.remove("roll");
    UI.redDie.classList.remove("roll");
  }, 400);

  // üßÆ Calculate movement direction
  const diff = Math.abs(g - r);
  let directionText, newIndex = GameState.currentTown;

  if (g > r) {
    directionText = `‚¨ÜÔ∏è Move UP ${diff} step${diff > 1 ? "s" : ""}`;
    newIndex = Math.min(GameState.towns.length - 1, GameState.currentTown + diff);
  } else if (r > g) {
    directionText = `‚¨áÔ∏è Move DOWN ${diff} step${diff > 1 ? "s" : ""}`;
    newIndex = Math.max(0, GameState.currentTown - diff);
  } else {
    directionText = "‚öñÔ∏è Equal dice! Caravan stays still.";
  }

  // ü™Ñ Show results before moving
  const msg = `üé≤ Dice rolled ‚Üí Green: ${g}, Red: ${r}. ${directionText}`;
  UI.log(msg);
  if (typeof Notifications !== "undefined") Notifications.show(msg);

  // üïí Wait 3 seconds before actual movement
  setTimeout(() => {
    if (newIndex !== GameState.currentTown) {
      GameState.currentTown = newIndex;
      const newTown = GameState.towns[newIndex];
      UI.log(`üê™ Caravan arrived at ${newTown}`);
      if (typeof Notifications !== "undefined") Notifications.show(`üê™ Caravan reached ${newTown}`);
      UI.updateTown();
      UI.refreshTable();
      positionPlayers();
      UI.highlightActivePlayer();
    }
  }, 3000);
};



/* =========================================
   MODULE: Dynamic Map + Sidebar Resizer
   ========================================= */
(function() {
  const container = document.querySelector(".container");
  const map = document.querySelector(".map");
  const sidebar = document.querySelector(".sidebar");

  // üß± Fix spacing
  container.style.display = "flex";
  container.style.gap = "0";
  container.style.alignItems = "flex-start";

  // ü™Ñ Create drag handle
  const handle = document.createElement("div");
  handle.id = "resizeHandle";
  handle.style.width = "8px";
  handle.style.cursor = "ew-resize";
  handle.style.background = "linear-gradient(180deg, #d6b370, #b87b2c)";
  handle.style.borderLeft = "2px solid #7a4f1a";
  handle.style.borderRight = "2px solid #7a4f1a";
  handle.style.height = "100%";
  handle.style.boxShadow = "inset 0 0 5px rgba(0,0,0,0.3)";
  container.insertBefore(handle, sidebar);

  // üñ±Ô∏è Handle drag logic
  let dragging = false;
  handle.addEventListener("mousedown", () => dragging = true);
  window.addEventListener("mouseup", () => dragging = false);
  window.addEventListener("mousemove", e => {
    if (!dragging) return;
    const rect = container.getBoundingClientRect();
    let newWidth = e.clientX - rect.left;
    newWidth = Math.max(400, Math.min(1100, newWidth)); // limit
    map.style.width = newWidth + "px";
  });

  // üß≠ Optional: Adjust sidebar to fill rest
  sidebar.style.flex = "1";
})();




init();
</script>
</body>
</html>
